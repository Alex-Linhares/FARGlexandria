unit FARG_Framework_Chunk;

interface

uses classes, graphics, sysutils, ibutils;

type
  TChunk = class;


  EnumState = (Propose, CheckStrength, CommitToMemory);  {"Imagine" for top-down, "interpret" synonym for bottom-up?}

  TConnotation = class {(TinterfacedObject)}
                    ExtMemoryRef: TObject;
                    ExpectedConnotation, ExpectedConnotationFound: TConnotation;
                    Relevance: real;
                    State: EnumState;
                    //Info: TConnotationInfo;

                    Procedure DeleteItemsThatIncludeConnotation(L:Tlist); virtual;
                    Function Contains (ConnotationType:TClass):boolean; virtual;
                    function InstancesOfConnotation (C:TConnotation):integer; virtual;
                    Procedure Codelet; {Change to state pattern and template pattern later on}
                    function ListAllConnotations(L: Tlist): Tlist; virtual;

                    {supporting actors}

                    {== codelets, MM style}
                    Function TopDownSeekFor(C: TConnotation):TConnotation;   virtual;
                    Procedure BottomUpPropose; virtual;  {This may be unnecessary (trade for searchforinstance?}
                    Procedure SearchForInstance; virtual; abstract; {NOT SURE THIS IS NEEDED, maybe only BottomUpPropose??}
                    Procedure CheckCurrentStrength; virtual; abstract;
                    Procedure CommitToSTM; virtual; abstract;
                    Procedure DeleteFromSTM; virtual;
                    Procedure Destroyer; virtual; abstract;
                end;

  TValue = class (TConnotation)
                 {incognita? UndefinedValue:boolean???}

                 Function GetValue: TObject; virtual; abstract;
                 Procedure SetValue(V: TObject); virtual; abstract;
                 Function {refactor to TSimilarity?} ExactValueCheck(N:TValue):boolean; virtual; abstract;

                 {== codelets, MM style}
                 Function TopDownSeekFor(C: TConnotation):TConnotation; override;
              end;

  TRelation = class (TConnotation)
                  Elements: tlist;
                  NewElements: tlist;
                  AcceptableConnotations:TList;

                  Constructor create;

                  Function Contains (ConnotationType:TClass):boolean;  override;
                  Function InstancesOfConnotation (C:TConnotation):integer;    override;

                  Procedure DeleteItemsThatIncludeConnotation(L:Tlist); override;

                  function ListAllConnotations(L: Tlist): Tlist;  override;
                  Procedure GetOriginalElements; virtual;
                  Function ConnotationIsAcceptable(C:TConnotation):boolean; virtual;
                  function GetConnotationOfType(T: TClass): TConnotation;
                  Procedure SetAcceptableConnotationsTypes; virtual; abstract;
                  Function ComputeRelation (RelatedItems: TList):TList; virtual; abstract;
                  Function ConditionsAreSatisfied: boolean; virtual; abstract;

                  {== codelets, MM style}
                  Procedure SearchForInstance; override;
                  Procedure CommitToSTM; override;
                  Procedure DeleteFromSTM; override;
              end;

  TChunk  = class (TRelation)

              Constructor Create;  overload;
              //Procedure CreateFromList (L: TList);  overload;

             {FROM TRELATION}
                  Function Contains (ConnotationType:TClass):boolean; override;
                  Function ConnotationIsAcceptable(C:TConnotation):boolean; override;
                  Procedure DeleteItemsThatIncludeConnotation(L:Tlist); override;
                  Procedure GetOriginalElements; override;
                  function GetConnotationOfType(T: TClass): TConnotation;
                  Procedure SetAcceptableConnotationTypes; virtual; abstract;
                  {Function ConditionsAreSatisfied: boolean; virtual; abstract;}


             {END FROM TRELATION}

              Function GetRelationsThatBindChunk: TList;
              Function GetConnotationsFromTheseRelations(Relations:TList):TList;

              {== codelets, MM style}
              Procedure BottomUpPropose; override;
              Function TopDownSeekFor(C: TConnotation):TConnotation; override;
              Procedure CommitToSTM; override;
              Procedure DeleteFromSTM; override;
              Procedure Destroyer; override;
            end;


{===========================================}

var     STM: TList;



implementation

{ TConnotation }

procedure TConnotation.Codelet;
{THIS SHOULD BE REFACTORED TO STATE PATTERN SOMEDAY}
begin
    Case State of
      Propose:
          begin
              if ExpectedConnotation<>nil then
                TopDownSeekFor(ExpectedConnotation) else
                BottomUpPropose;
          end;

      CheckStrength: CheckCurrentStrength;

      CommitToMemory: CommitToSTM;
      end;
end;

function TConnotation.InstancesOfConnotation(C: TConnotation): integer;
begin
    if self=C then result:=1 else result:=0;
end;

function TConnotation.ListAllConnotations(L: Tlist): Tlist;
begin
    L:=Tlist.Create;
    L.Add(self);
    result:=L;
end;

Procedure TConnotation.BottomUpPropose;
begin
  SearchForInstance;
end;

function TConnotation.Contains(ConnotationType: TClass): boolean;
begin
    if self.ClassType<>ConnotationType then
      result:= false else result:=true;
end;

Function TConnotation.TopDownSeekFor(C: TConnotation):TConnotation;
begin
    {This method looks for a sentconnotation and creates a scout (proposal)}
    {one connotation is being searched... it could have a value,
     or it could have an UndefinedValue (only the type is being searched for)}
    {How do we know if the connotation is there? We must look into STM}
    {Is there a difference between finding a specific value OR only a type?}

    {How to check if two objects are equal?  Let's say we're looking for a number
    in Numbo... then that's easy: check the value; but what if we're looking for
    a 100+10=110 chunk? How to compare whole structures? Maybe AllChunkConnotations
    can be used?  this has many levels and many connotations and values,
    which make the test much harder...}

    {examples of method in action, different hierarchical levels:

    NUMBO:    looks for a particular number or result
              looks whether a particular number can result from some operation
              Jarbas system; looks for a particular type of operation? x+y=z ?

    Copycat:  looks for a successorship_relation between any two letters
              looks for a chunk of a certain type (sameness, successorship, etc)

    Chess:    looks for upcoming moves of a certain piece
              looks for interceptions of certain relations

    Bongard Problems: looks for certain types of geometrical objects
                      looks for certain types of relations between objects

    So,
    (i) we have a certain connotation which is expected to be found in STM or external memory
    (ii) With this SentConnotation, we browse memory systems in search of it...
    (iii) How do we browse memory systems?
      (a) each ExpectedConnotation can only be found in a certain types of conotations
          (e.g., it is useless to browse a tbrick for a multiplication, or a letter for
           a sucessorship group, or a chess queen for an attack, or a triangle for a bigger-than
           relation)
           So, for each ExpectedConnotation, we should define a method like
           ToScan:=CanBeFoundIn(ExpectedConnotations):Tlist;
      (b) after we have a set of things ToScan, we should, perhaps, apply this:
           C:=ToScan.Items[x];  (C=random item of a good connotation type)
           C.SearchForInstance; (This method is type-only, value neutral... so
                                 there should be another method in which the VALUE
                                 is being searched for.)

                                 BRAINSTORM: How does this compare to the idea of an incognita???

      So what is the difference between bottom-up and top-down codelets?

      bottom up just SearchForInstance
      top-down have to scan a list of good connotations???  IN STM alone?  Or in EM also?
    }

   {TCHUNK calls this for each internal connotation}
   ExpectedConnotation:=C;
   ExpectedConnotationFound:=nil;
   if ExpectedConnotation.ClassType=Self.ClassType then   {Checking exact classes here}
   begin
      ExpectedConnotationFound:=self;
   end;
   result:=ExpectedConnotationFound;
end;


Procedure TConnotation.DeleteFromSTM;
begin
    //does nothing
end;



procedure TConnotation.DeleteItemsThatIncludeConnotation(L: Tlist);
begin
    L.Remove(self);
end;

{ TChunk }

Function TChunk.ConnotationIsAcceptable(C:TConnotation):boolean;
var ConnotationIsValid:boolean; y:integer;
begin
     ConnotationIsValid:=False;
     for y:=0 to AcceptableConnotations.count-1 do
        if (C.Classtype=AcceptableConnotations.items[y]) then
            ConnotationIsValid:=true;
     Result:=ConnotationIsValid;
end;


Function TChunk.TopDownSeekFor(C: TConnotation):TConnotation;
var
  I: Integer;
  Aux: TConnotation;
begin
  ExpectedConnotation:=C;
  {looks for the conotation inside the chunk (but should also look if the chunk is a perfect match)}
  if (ExpectedConnotationFound<>self) then
  begin
    for I := 0 to Elements.Count - 1 do
    begin
      aux:=Elements.Items[i];
      ExpectedConnotationFound := aux.TopDownSeekFor (ExpectedConnotation);
    end;
  end;
  result:=ExpectedConnotationFound;
end;


procedure TChunk.GetOriginalElements;
begin
end;


constructor TChunk.Create;
begin
    NewElements:=Tlist.Create;
    Elements:= Tlist.Create;
    AcceptableConnotations:=TList.create;
    SetAcceptableConnotationTypes;
end;


Procedure TChunk.DeleteFromSTM;
begin

end;

procedure TChunk.DeleteItemsThatIncludeConnotation(L: Tlist);
var c: TConnotation; j:integer;
begin
     For J:= 0 to elements.count-1 do
     begin
        C:= elements.Items[j];
        if C.InheritsFrom(TChunk) then
        begin
            Tchunk(C).DeleteItemsThatIncludeConnotation(L);
        end else if C.InheritsFrom(TRelation) then
              TRelation(C).DeleteItemsThatIncludeConnotation(L)
        else L.Remove(C);
     end;
end;

Procedure TChunk.BottomUpPropose;
Var C:Tconnotation; R:TRelation; I:integer;
begin
    //look for one of these connotations in STM
    C:=STM.Items[random(STM.count)];
    if ConnotationIsAcceptable(c) then
    begin
       elements.add(C);
       if (C.InheritsFrom(Tchunk)) then
       begin
            R:=TRelation(C);
            for I := 0 to R.NewElements.Count - 1 do
                Elements.Add(R.NewElements.Items[i]);
            for I := 0 to R.Elements.Count - 1 do
                Elements.Add(R.Elements.Items[i]);
       end;
       state:=CommitToMemory;
    end;

    If State=CommitToMemory then
    begin
        CommitToSTM; //Has to be called from client.  REFACTOR!
        State:=propose;
    end;
end;

procedure TChunk.CommitToSTM;
var i: integer; L1, L2, Intersection:TList; C:TConnotation;
begin
    {2 parts: (i) withdraw elements from STM, and (ii) insert chunk in STM}
    {PART (i)}
    L1:=TList.Create;
    L1:=self.ListAllConnotations(L1);

    i:=0;
    while (i<STM.Count) do
    begin
        C:=STM.items[i];
        L2:=TList.Create;
        L2:=C.ListAllConnotations(L2);
        Intersection:=TList.Create;
        Intersection.Assign(L1, laAnd, L2);
        if Intersection.Count>0 then
        begin
            STM.Remove(C);
            i:=i-1;
        end;
        i:=i+1;
    end;


    {Part (ii)}
    STM.Add(self);
end;


procedure TChunk.Destroyer;
var Relations, Connotations: TList;
    C: TConnotation;
    I: integer;
begin
    {First:  find the relations binding the stuff inside the chunk}
    Relations:=GetRelationsThatBindChunk;

    {Second: find the set of Connotations these relations are using.
    Notice that not all connotations are used: for example, 2x5 creates
    a 10 as a TResult, but the 10 should not go back to STM}

    Connotations:=GetConnotationsFromTheseRelations(Relations);
    {Third: Commit these Connotations back to STM; destroy everything in
    the Chunk
    Scan the chunk, deleting everything for which the template does not match
    the desired set of connotations}

    STM.Remove(self);
    STM.Pack;

    {put the items back in STM}
    for I := 0 to Connotations.Count - 1 do
    begin
        C:=Connotations.Items[i];
        STM.Add(C);
    end;
    {We are not _yet_ commiting these relations to memory...
    so not needed now...}
    for I := 0 to Relations.Count - 1 do
    begin
        C:=Relations.Items[i];
        STM.Add(C);
    end;

    {Now delete the chunk baby!}
    Elements.Clear;
    Destroy;
end;

function TChunk.GetConnotationsFromTheseRelations(Relations: TList): TList;
var I, I2:integer;
    R:TRelation;
    C:TConnotation;
    List:TList;
begin
    List:=Tlist.Create;
    For I:=0 to Relations.Count-1 do
    begin
         R:=Relations.Items[I];
         for I2 := 0 to R.Elements.Count - 1 do
         begin
             C:=R.Elements.Items[I2];
             List.Add(C);
         end;
    end;
    result:=list;
end;

function TChunk.GetRelationsThatBindChunk: TList;
var L:TList;
  I: Integer;
  C: TConnotation;
begin
    L:=Tlist.Create;
    for I := 0 to Elements.Count - 1 do
    begin
        C:=Elements.Items[i];
        if C.InheritsFrom(TRelation) then
          L.Add(C);
    end;
    Result:=L;
end;


//REFACTOR THESE TWO, THEN THEY GO TO TINFO!
function TChunk.GetConnotationOfType(T: TClass): TConnotation;
Var C, res:TConnotation; I: integer; Caux:TRelation;
begin
   res:=nil;
   for I := 0 to Elements.Count - 1 do
   begin
     C:=Elements.Items[i];
     if C.ClassType=T then
     begin
        res:=C;
     end
     else if (C.inheritsFrom(TRelation)) then
     begin
        CAux:=TRelation(C);
        res:=Caux.getConnotationOfType(T);
     end;
   end;
   result:=res;
end;

function TChunk.Contains(ConnotationType: TClass): boolean;
var C: TConnotation;
    I: integer;
    res:boolean;
begin
    res:=false;
    for I := 0 to Elements.Count - 1 do
    begin
       C:=Elements.Items[i];
       if C.inheritsFrom(ConnotationType) then
          res:= true;
    end;
    result:=res;
end;


{ TRelation }

Constructor TRelation.create;
begin
    Inherited;
    AcceptableConnotations:=Tlist.Create;
    SetAcceptableConnotationsTypes;

    Elements:=TList.Create;
    NewElements:=TList.Create;
end;

function TRelation.Contains(ConnotationType: TClass): boolean;
var C: TConnotation;
    I: integer;
    res:boolean;
begin
    res:=false;
    for I := 0 to Elements.Count - 1 do
    begin
       C:=Elements.Items[i];
       if C.ClassType=ConnotationType then
          res:= true;
    end;
    result:=res;
end;

function TRelation.GetConnotationOfType(T: TClass): TConnotation;
Var C:TConnotation; I: integer; List:TList;
begin
   Result:=nil;
   List:=TList.Create;
   for I := 0 to Elements.Count - 1 do
      List.add(Elements.items[i]);
   for I := 0 to NewElements.Count - 1 do
      List.add(NewElements.items[i]);
   for I := 0 to List.Count - 1 do
   begin
     C:=List.Items[i];
     if C.inheritsFrom(T) then
        result:=C;
   end;
end;

procedure TRelation.SearchForInstance;
begin
     //VERY BAD METHOD NAME!!! 
     GetOriginalElements; //Template method: call handled by subclasses
end;

function TRelation.ListAllConnotations(L: Tlist): Tlist;
var
  I: Integer; Caux:TConnotation;
begin
    for I := 0 to Elements.Count - 1 do
    begin
      Caux:=Elements.items[i];
      L.add(Caux);
      if Caux.InheritsFrom(TRelation) then
          L:=TRelation(Caux).ListAllConnotations(L);
    end;
    result:=L;
end;



function TRelation.InstancesOfConnotation(C: TConnotation): integer;
var
  I: Integer; Caux:TConnotation;
begin   //return the instances of connotation C found inside the relation
    result:=0;
    for I := 0 to Elements.Count - 1 do
    begin
      Caux:=Elements.items[i];
      if Caux=C then
        result:=result+1
      else if Caux.InheritsFrom(TRelation) then
          result:=result+TRelation(Caux).InstancesOfConnotation(C);
    end;
end;

Function TRelation.ConnotationIsAcceptable(C:TConnotation):boolean;
var ConnotationIsValid:boolean; y:integer;
begin
     ConnotationIsValid:=False;
     for y:=0 to AcceptableConnotations.count-1 do
        if (C.Contains(AcceptableConnotations.items[y])) then
            ConnotationIsValid:=true;
     Result:=ConnotationIsValid;
end;



Procedure TRelation.GetOriginalElements;
var c1, c2:TConnotation; L1, L2, Intersection:TList;
begin
    {get 2 elements from STM; they must be different and with good connotations}
    While (Elements.count<2) do
    begin
        ConditionsAreSatisfied;  //terrible name here
        c1:=elements.items[0];
        c2:=elements.items[1];
        L1:=Tlist.create;
        L2:=TList.create;
        Intersection:=TList.create;
        L1:=C1.ListAllConnotations(L1);
        L2:=C2.ListAllConnotations(L2);
        Intersection.Assign(L1, laAnd, L2);
        if Intersection.Count>0 then
            Elements.Clear;
    end;
end;


procedure TRelation.CommitToSTM;
// Template method (subclasses handle the calls)
begin
    if ConditionsAreSatisfied then
    begin
         ComputeRelation(Elements);
         STM.Add(self);
    end;
end;

Procedure TRelation.DeleteFromSTM;
begin
end;

procedure TRelation.DeleteItemsThatIncludeConnotation(L: Tlist);
var c: TConnotation; j:integer;
begin
     For J:= 0 to elements.count-1 do
     begin
        C:= elements.Items[j];
        if C.InheritsFrom(TChunk) then
        begin
            Tchunk(C).DeleteItemsThatIncludeConnotation(L);
        end else if C.InheritsFrom(TRelation) then
              TRelation(C).DeleteItemsThatIncludeConnotation(L)
        else L.Remove(C);
     end;
end;

{ TValue }

Function TValue.TopDownSeekFor(C: TConnotation):TConnotation;
begin
     ExpectedConnotation:=C;
     ExpectedConnotationFound:=nil;

     if ExpectedConnotation.InheritsFrom(TValue) then
     begin
        if (ExactValueCheck(TValue(ExpectedConnotation))) then {EXACT VALUE CHECKING}
        begin
          {result must point to the right connotation where the thing was found!}
          ExpectedConnotationFound := self;
        end;
     end;
     result:=ExpectedConnotationFound;
end;


{
Thoughts on the STATE refactoring...
(i) how to include proposed structures without chunking them up?
        just create the list in a proposal object
(ii) how to accept proposed structures?
        check the proposal's value, and, if accepted, create a chunk?

CAN IT WORK FOR ALL CONNOTATIONS?  ONLY RELATIONS?

    well, I can have 50 copies of random proposals full of lists
    running around, as long as they don't change STM.  As long as
    nothing is taken from STM, and no chunk is created, thousands of
    proposals can be pointing to some cool stuff to do there, irresponsibly

    But sometimes we do create a bond without chunking it up in copycat,
    or maybe in chess (attacks, etc.) So we could have a commit for
    some relations.

    A new TRelation: How is it attached to anything?  Well, it
    has a List of the original connotations, and a list of the newly created
    connotations.

    A new Chunk: It either groups things based on some (set of) relations. Are
    chunks also relations?  What would the advantages be?  Interface advantages?

    A new Property:  Created when a new relation or a new chunk is created,
    automaticaly bound to a relation or a chunk

We have to do it bottom-up & top-down!

When Bottom-up, we just get things from EM and STM (never inside chunks)

When top-down, we also look inside the chunks, because we might want to
break them apart (and maybe recreate directly the new interpretation? like
a necker cube or a faces/vases illusion)?

1. TRelation should NOT create a chunk: it should be created when
    TCHUNK.conditions are satisfied;
2. A Chunk should find its own properties and relations (and chunks) and Commit
3. TRelation should commit to STM (just like chunks; but without deleting
    anything)
4. Separation of Creation to Commit to STM
5. Shared interface between TRelation and TChunk?
    does a chunk have EVERYTHING that a relation has????
    A chunk has a crucial difference, as it actually deletes stuff from STM
}


end.
